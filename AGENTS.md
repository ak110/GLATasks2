# カスタム指示

## 基本原則

- 以下を念頭に置いて実装を進めること
  - DRY: **Don't Repeat Yourself**
  - KISS: **Keep It Simple, Stupid**
  - SSOT: **Single Source Of Truth**
  - SRP: **Single Responsibility Principle**
  - コードには How、
    テストコードには What、
    コミットログには Why、
    コードコメントには Why not を書く。
- 必要に応じて`git grep`コマンドを活用して影響範囲やコードスタイルを調査する
- 新しいファイルを作成する際は、近い階層の代表的なファイルを確認し、スタイルを揃える
- コードを書いた後は必ず整形およびテストコードの実行をする (`make test`)
  - Lintエラー・テスト失敗は、その時実施中の作業に無関係のものであっても一緒に対応する
- ライブラリ・パッケージの追加や更新は勝手に行わない(ユーザーの同意を必須とする)
- 作業中にバグや不統一な実装などを見つけた場合、指示に関係ない箇所であってもユーザーに修正を提案すること (勝手に修正はしないこと。ユーザーの同意を必須とする)
- ユーザーへの質問・確認はいくつ出してもよい (思い込みで進めることを避け、積極的にユーザーの意図・意向を確認すること)
- 作業がひと段落したらコミットして
  - なお、直前のコミットが未プッシュで、かつコミットする内容と似た内容の場合はamendして必要に応じてメッセージを更新して
  - 判断が難しい場合はユーザーに確認して

## 関連ドキュメント

- @README.md
- @docs/architecture.md
- @docs/development.md
- @docs/coding-style.md

## その他のふるまい

- バグを作りこみ、ユーザーの指摘で修正した場合、
  修正完了後に同様の問題が再発しないようにdocs/development.md の「開発時の注意点」に追記する

---

## ワークフロー設計

### 1. Planモードを基本とする

- 3ステップ以上 or アーキテクチャに関わるタスクは必ずPlanモードで開始する
- 途中でうまくいかなくなったら、無理に進めずすぐに立ち止まって再計画する
- 構築だけでなく、検証ステップにもPlanモードを使う
- 曖昧さを減らすため、実装前に詳細な仕様を書く

### 2. サブエージェント戦略

- メインのコンテキストウィンドウをクリーンに保つためにサブエージェントを積極的に活用する
- リサーチ・調査・並列分析はサブエージェントに任せる
- 複雑な問題には、サブエージェントを使ってより多くの計算リソースを投入する
- 集中して実行するために、サブエージェント1つにつき1タスクを割り当てる

### 3. 自己改善ループ

- ユーザーから修正を受けたら必ず `AGENTS.md` の `## Lessons Learned` にそのパターンを記録する
- 同じミスを繰り返さないように、自分へのルールを書く
- ミス率が下がるまで、ルールを徹底的に改善し続ける
- セッション開始時に、そのプロジェクトに関連するlessonsをレビューする

### 4. 完了前に必ず検証する

- 動作を証明できるまで、タスクを完了とマークしない
- 必要に応じてmainブランチと自分の変更の差分を確認する
- 「スタッフエンジニアはこれを承認するか？」と自問する
- テストを実行し、ログを確認し、正しく動作することを示す

### 5. エレガントさを追求する（バランスよく）

- 重要な変更をする前に「もっとエレガントな方法はないか？」と一度立ち止まる
- ハック的な修正に感じたら「今知っていることをすべて踏まえて、エレガントな解決策を実装する」
- シンプルで明白な修正にはこのプロセスをスキップする（過剰設計しない）
- 提示する前に自分の作業に自問自答する

### 6. 自律的なバグ修正

- バグレポートを受けたら、手取り足取り教えてもらわずにそのまま修正する
- ログ・エラー・失敗しているテストを見て、自分で解決する
- ユーザーのコンテキスト切り替えをゼロにする
- 言われなくても、失敗しているCIテストを修正しに行く

---

## タスク管理

1. **まず計画を立てる**：チェック可能な項目として計画を書く
2. **計画を確認する**：実装を開始する前に確認する
3. **進捗を記録する**：完了した項目を随時マークしていく
4. **変更を説明する**：各ステップで高レベルのサマリーを提供する
5. **結果をドキュメント化する**：計画にレビューセクションを追加する
6. **学びを記録する**：修正を受けた後に `AGENTS.md` の `## Lessons Learned` を更新する

---

## コア原則

- **シンプル第一**：すべての変更をできる限りシンプルにする。影響するコードを最小限にする。
- **手を抜かない**：根本原因を見つける。一時的な修正は避ける。シニアエンジニアの水準を保つ。
- **影響を最小化する**：変更は必要な箇所のみにとどめる。バグを新たに引き込まない。

---

## Lessons Learned

### tRPC v11 ミドルウェアの注意点

- tRPC v11 のミドルウェアには `rawInput` パラメータが存在しない。`getRawInput()` 関数を `await` して使う。
- `decryptToString()` / `encryptObject()` は `async` 関数。必ず `await` すること。
- ミドルウェアで出力を変更する場合、新しいオブジェクトを返すと tRPC の型推論が壊れる。`result` を直接変更（`as unknown as Record<string, unknown>`）して型を保持する。

### @tanstack/svelte-query と Svelte 5 runes の互換性

- `@tanstack/svelte-query` v5.90.2 の `createQuery` は `StoreOrVal<T> = T | Readable<T>` のみ対応。関数形式 `() => options` はサポートされない（型もランタイムも動かない）。
- リアクティブなクエリオプションが必要な場合は `derived` ストアを使い、rune から `$effect` で同期する。

### tRPC observable リンクの async ハンドラ

- `observable` の `next` コールバックが `async` の場合、`complete` が非同期処理完了前に発火する。
- `pending` で Promise を追跡し、`complete` 時に `then()` で待つ必要がある。

### JavaScript の `String.split(sep, limit)` の罠

- `"a\nb\nc".split("\n", 2)` は `["a", "b"]` を返し、`"c"` は捨てられる。Python と異なり、残りが末尾要素に結合されない。
- 「最初の区切りで2分割したい」場合は `indexOf` + `slice` を使うこと。
