# カスタム指示

## 基本原則

- **シンプル第一**：すべての変更をできる限りシンプルにする。影響するコードを最小限にする。
- **手を抜かない**：根本原因を見つける。一時的な修正は避ける。シニアエンジニアの水準を保つ。
- **影響を最小化する**：変更は必要な箇所のみにとどめる。バグを新たに引き込まない。
- 途中でうまくいかなくなったら、無理に進めずすぐに立ち止まって再計画する
- 新しいコードを書くときは必ず既存部分と共通できないかよく検討すること (必要に応じて既存部分も修正して共通化する)
  - DRY: **Don't Repeat Yourself**
  - KISS: **Keep It Simple, Stupid**
  - SSOT: **Single Source Of Truth**
  - SRP: **Single Responsibility Principle**
- 既存コードに対しても積極的にリファクタリングを検討し、ユーザーに提案すること (勝手にやらないこと。ユーザーの同意を必須とする)
- 1行程度で済む処理は基本的に関数化しない (可読性が著しく低下する場合に限り関数化を検討する)
- コードには適度にコードコメントを書く
  - コメントは以下の内容に限る
    - 「なぜそうするか（設計上の制約、トレードオフ、バグ回避理由）」
    - 「何をしているか（数行以上のコードの塊に対して短い要約として）」
  - 参考: コードには How、テストコードには What、コミットログには Why、コードコメントには Why not を書く
- 必要に応じて`git grep`コマンドなどを活用して影響範囲やコードスタイルを調査する
- 新しいファイルを作成する際は、近い階層の代表的なファイルを確認し、スタイルを揃える
- 新しいpublicな関数などを書く際は、必ずテストコードも書く
  - テストコードの目標カバレッジは80%程度 (ただしあまり数字にこだわらず、重要なロジックやバグが起きやすい箇所を優先的にカバーすること。特に指示が無ければ計測も不要)
- コードを書いた後は必ず整形およびテストコードの実行をする (`make test`)
  - Lintエラー・テスト失敗は、その時実施中の作業に無関係のものであっても一緒に対応する
- ライブラリ・パッケージの追加や更新は勝手に行わない(ユーザーの同意を必須とする)
- 作業中にバグや不統一な実装などを見つけた場合、指示に関係ない箇所であってもユーザーに修正を提案すること (勝手に修正はしないこと。ユーザーの同意を必須とする)
- ユーザーへの質問・確認はいくつ出してもよい (思い込みで進めることを避け、積極的にユーザーの意図・意向を確認すること)
- 作業がひと段落したらコミットして
  - なお、直前のコミットが未プッシュで、かつコミットする内容と似た内容の場合はamendして必要に応じてメッセージを更新して
  - 判断が難しい場合はユーザーに確認して

### サブエージェント戦略

- メインのコンテキストウィンドウをクリーンに保つためにサブエージェントを積極的に活用する
- リサーチ・調査・並列分析はサブエージェントに任せる
- 複雑な問題には、サブエージェントを使ってより多くの計算リソースを投入する
- 集中して実行するために、サブエージェント1つにつき1タスクを割り当てる

### 自己改善ループ

- ユーザーから修正を受けたら必ず `AGENTS.md` の `## Lessons Learned` にそのパターンを記録する
- 同じミスを繰り返さないように、自分へのルールを書く
- ミス率が下がるまで、ルールを徹底的に改善し続ける
- セッション開始時に、そのプロジェクトに関連するlessonsをレビューする

### 完了前に必ず検証する

- 動作を証明できるまで、タスクを完了とマークしない
- 必要に応じてmainブランチと自分の変更の差分を確認する
- 「スタッフエンジニアはこれを承認するか？」と自問する
- テストを実行し、ログを確認し、正しく動作することを示す

### エレガントさを追求する（バランスよく）

- 重要な変更をする前に「もっとエレガントな方法はないか？」と一度立ち止まる
- ハック的な修正に感じたら「今知っていることをすべて踏まえて、エレガントな解決策を実装する」
- シンプルで明白な修正にはこのプロセスをスキップする（過剰設計しない）
- 提示する前に自分の作業に自問自答する

### 自律的なバグ修正

- バグレポートを受けたら、手取り足取り教えてもらわずにそのまま修正する
- ログ・エラー・失敗しているテストを見て、自分で解決する
- ユーザーのコンテキスト切り替えをゼロにする
- 言われなくても、失敗しているCIテストを修正しに行く

## 関連ドキュメント

- @README.md
- @docs/architecture.md
- @docs/development.md
- @docs/coding-style.md

---

## Lessons Learned

### tRPC v11 ミドルウェアの注意点

- tRPC v11 のミドルウェアには `rawInput` パラメータが存在しない。`getRawInput()` 関数を `await` して使う。
- `decryptToString()` / `encryptObject()` は `async` 関数。必ず `await` すること。
- ミドルウェアで出力を変更する場合、新しいオブジェクトを返すと tRPC の型推論が壊れる。`result` を直接変更（`as unknown as Record<string, unknown>`）して型を保持する。

### @tanstack/svelte-query と Svelte 5 runes の互換性

- `@tanstack/svelte-query` v5.90.2 の `createQuery` は `StoreOrVal<T> = T | Readable<T>` のみ対応。関数形式 `() => options` はサポートされない（型もランタイムも動かない）。
- リアクティブなクエリオプションが必要な場合は `derived` ストアを使い、rune から `$effect` で同期する。

### tRPC observable リンクの async ハンドラ

- `observable` の `next` コールバックが `async` の場合、`complete` が非同期処理完了前に発火する。
- `pending` で Promise を追跡し、`complete` 時に `then()` で待つ必要がある。

### JavaScript の `String.split(sep, limit)` の罠

- `"a\nb\nc".split("\n", 2)` は `["a", "b"]` を返し、`"c"` は捨てられる。Python と異なり、残りが末尾要素に結合されない。
- 「最初の区切りで2分割したい」場合は `indexOf` + `slice` を使うこと。
